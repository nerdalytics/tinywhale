# Dispatch Strategy 1: Monomorphization + Per-Function Tables

> **Summary**: Specialize functions at compile time. Use one WASM table per generic function for runtime dispatch when union types are involved.

---

## Table of Contents

1. [Core Concept](#core-concept)
2. [How It Works](#how-it-works)
3. [Type Tags](#type-tags)
4. [WASM Implementation](#wasm-implementation)
5. [Binaryen Code Generation](#binaryen-code-generation)
6. [Multi-Argument Dispatch](#multi-argument-dispatch)
7. [Performance Characteristics](#performance-characteristics)
8. [Trade-offs](#trade-offs)
9. [When to Use](#when-to-use)

---

## Core Concept

**Monomorphization** is the process of generating specialized code for each concrete type at compile time. Combined with **per-function dispatch tables**, this strategy:

1. Generates specialized function variants for each type in a union
2. Uses direct calls when the concrete type is statically known
3. Falls back to `call_indirect` via a per-function table when dispatching on union types

This mirrors how Rust handles generics (monomorphization) combined with trait objects (vtables).

---

## How It Works

### Compile-Time Phase

Given this TinyWhale code:

```tinywhale
Person
    id: i32
    age: i32<min=0>
    name: String
    sex?: Male | Female | Other

greet_person = (p: Person) -> String
    match p.sex as s
        s -> match s
            Male -> "Hello Mr"
            Female -> "Hello Mrs"
            _ -> "Hello"
        _ -> "Hi"
```

The compiler:

**Step 1: Expand optional fields into variant types**

```tinywhale
# Generated by compiler
Person$without_sex
    __type_tag: i32  # = 0
    id: i32
    age: i32
    name: String

Person$with_sex
    __type_tag: i32  # = 1
    id: i32
    age: i32
    name: String
    sex: Male | Female | Other

# Union alias
Person = Person$without_sex | Person$with_sex
```

**Step 2: Generate specialized function variants**

```tinywhale
# Variant for Person without sex field
greet_person$0 = (p: Person$without_sex) -> String
    "Hi"  # No sex field, use default

# Variant for Person with sex field
greet_person$1 = (p: Person$with_sex) -> String
    match p.sex
        Male -> "Hello Mr"
        Female -> "Hello Mrs"
        _ -> "Hello"
```

**Step 3: Create dispatch table**

```
Table: $greet_person$dispatch
  Index 0 → greet_person$0
  Index 1 → greet_person$1
```

**Step 4: Generate dispatch wrapper**

```tinywhale
# Only used when caller has union type
greet_person = (p: Person) -> String
    # Read type tag from p, use as table index
    call_indirect($greet_person$dispatch, p.__type_tag, p)
```

### Runtime Phase

At call sites:

```tinywhale
# Case A: Static type known → direct call
p1 = Person$with_sex { id = 1, age = 30, name = "Alice", sex = Female }
greeting1 = greet_person(p1)  # Compiles to: call $greet_person$1

# Case B: Union type → indirect call
get_person = (): Person -> ...  # Returns either variant
p2 = get_person()
greeting2 = greet_person(p2)  # Compiles to: call $greet_person (dispatch wrapper)
```

---

## Type Tags

### What Are Type Tags?

A **type tag** is a small integer that identifies the concrete type of a value at runtime. For union types, each variant gets a unique tag.

### Storage Options

> **Note**: TinyWhale uses **linear memory** for struct storage, not WasmGC. This is intentional — WasmGC is not yet supported in WASI runtimes (wasmtime, wasmer, etc.).

**Option A: Embedded in struct (recommended for TinyWhale)**

Type tag is the first field of every union-typed struct in linear memory:

```
Memory layout for Person$without_sex:
  Offset 0:  type_tag (i32) = 0
  Offset 4:  id (i32)
  Offset 8:  age (i32)
  Offset 12: name_ptr (i32)

Memory layout for Person$with_sex:
  Offset 0:  type_tag (i32) = 1
  Offset 4:  id (i32)
  Offset 8:  age (i32)
  Offset 12: name_ptr (i32)
  Offset 16: sex (i32)
```

**Lookup**: O(1) — single `i32.load` at known offset (0).

```wasm
;; Load type tag from struct pointer
(i32.load (local.get $ptr))  ;; Returns 0 or 1
```

**Option B: Separate type registry**

```
Type Registry (global array):
  registry[ptr] = type_tag

Value memory layout (no embedded tag):
  Offset 0: id (i32)
  Offset 4: age (i32)
  ...
```

**Lookup**: O(1) — but requires extra indirection and registry management.

**Recommendation**: Option A. Embedding the tag is simpler and avoids maintaining a separate registry.

### Tag Assignment

Tags are assigned at compile time based on union definition order:

```tinywhale
Person = Person$without_sex | Person$with_sex
#        Tag 0              | Tag 1
```

For nested unions or multiple optionals:

```tinywhale
Data
    a?: i32
    b?: i32

# Generates 4 variants:
Data$none      # tag 0: neither a nor b
Data$a         # tag 1: only a
Data$b         # tag 2: only b
Data$a_b       # tag 3: both a and b
```

---

## WASM Implementation

### Module Structure

```wasm
(module
  ;; Type definitions
  (type $person_method (func (param i32) (result i32)))

  ;; Dispatch table for greet_person
  (table $greet_person$dispatch 2 2 funcref)

  ;; Populate table with specialized variants
  (elem (table $greet_person$dispatch) (i32.const 0)
    $greet_person$0
    $greet_person$1)

  ;; Specialized variant 0 (without sex)
  (func $greet_person$0 (param $p i32) (result i32)
    ;; Return pointer to "Hi" string
    (i32.const 100))

  ;; Specialized variant 1 (with sex)
  (func $greet_person$1 (param $p i32) (result i32)
    ;; Load sex field at offset 16
    (i32.load offset=16 (local.get $p))
    ;; Match and return appropriate greeting
    ;; ... (match implementation)
    )

  ;; Dispatch wrapper (called for union types)
  (func $greet_person (param $p i32) (result i32)
    (call_indirect $greet_person$dispatch (type $person_method)
      (local.get $p)                    ;; argument
      (i32.load (local.get $p))))       ;; type tag at offset 0

  ;; Direct call example (static type known)
  (func $example_direct (result i32)
    (call $greet_person$1               ;; direct call to variant 1
      (i32.const 200)))                 ;; pointer to Person$with_sex

  ;; Indirect call example (union type)
  (func $example_indirect (param $p i32) (result i32)
    (call $greet_person                 ;; goes through dispatch wrapper
      (local.get $p)))
)
```

### Key Instructions

| Instruction | Purpose |
|-------------|---------|
| `(table $name N M funcref)` | Declare table with N initial, M max entries |
| `(elem (table $name) (i32.const offset) $fn1 $fn2)` | Populate table entries |
| `(call_indirect $table (type $sig) args... index)` | Indirect call via table |
| `(i32.load (local.get $ptr))` | Load type tag from struct |

---

## Binaryen Code Generation

### TypeScript Implementation

```typescript
import binaryen from 'binaryen'

interface FunctionVariant {
  name: string
  typeTag: number
  wasmFunc: string
}

interface GenericFunction {
  name: string
  variants: FunctionVariant[]
  paramType: binaryen.Type
  returnType: binaryen.Type
}

function emitDispatchTable(
  module: binaryen.Module,
  func: GenericFunction
): void {
  const tableName = `${func.name}$dispatch`
  const variantNames = func.variants.map(v => v.wasmFunc)

  // Create table with exact size needed
  module.addTable(
    tableName,
    variantNames.length,  // initial
    variantNames.length,  // max
    binaryen.funcref
  )

  // Populate table with function references
  module.addActiveElementSegment(
    tableName,
    `${tableName}$elem`,
    variantNames,
    module.i32.const(0)  // offset
  )
}

function emitDispatchWrapper(
  module: binaryen.Module,
  func: GenericFunction
): void {
  const tableName = `${func.name}$dispatch`

  // Create dispatch wrapper function
  module.addFunction(
    func.name,
    binaryen.createType([binaryen.i32]),  // param: pointer
    func.returnType,
    [],  // no locals
    module.call_indirect(
      tableName,
      // Type tag loaded from offset 0 of struct
      module.i32.load(0, 0, module.local.get(0, binaryen.i32)),
      // Pass through the argument
      [module.local.get(0, binaryen.i32)],
      func.paramType,
      func.returnType
    )
  )
}

function emitCall(
  module: binaryen.Module,
  callee: string,
  arg: binaryen.ExpressionRef,
  staticTypeTag: number | null  // null if union type
): binaryen.ExpressionRef {
  if (staticTypeTag !== null) {
    // Static type known → direct call to specialized variant
    return module.call(`${callee}$${staticTypeTag}`, [arg], binaryen.i32)
  } else {
    // Union type → call dispatch wrapper
    return module.call(callee, [arg], binaryen.i32)
  }
}
```

### Generated WAT Output

For `greet_person` with 2 variants:

```wasm
;; Dispatch table
(table $greet_person$dispatch 2 2 funcref)
(elem $greet_person$dispatch$elem (table $greet_person$dispatch) (i32.const 0)
  $greet_person$0
  $greet_person$1)

;; Dispatch wrapper
(func $greet_person (param $0 i32) (result i32)
  (call_indirect $greet_person$dispatch (type $person_method)
    (local.get $0)
    (i32.load (local.get $0))))

;; At call site with known type
(call $greet_person$1 (local.get $person_ptr))

;; At call site with union type
(call $greet_person (local.get $person_ptr))
```

---

## Multi-Argument Dispatch

For functions with multiple union-typed parameters, this strategy extends using **table composition**.

### Example: Two Union Parameters

```tinywhale
# Both Person and Greeting have variants
greet = (p: Person, style: GreetingStyle) -> String
```

Where:
- `Person` has 2 variants (tags 0, 1)
- `GreetingStyle` has 3 variants (tags 0, 1, 2)

### Approach A: Flattened Table

Compute a combined index: `index = person_tag * 3 + style_tag`

```
Table $greet$dispatch (size 6):
  [0]: greet$0$0  (Person variant 0, Style variant 0)
  [1]: greet$0$1  (Person variant 0, Style variant 1)
  [2]: greet$0$2  (Person variant 0, Style variant 2)
  [3]: greet$1$0  (Person variant 1, Style variant 0)
  [4]: greet$1$1  (Person variant 1, Style variant 1)
  [5]: greet$1$2  (Person variant 1, Style variant 2)
```

```wasm
(func $greet (param $p i32) (param $style i32) (result i32)
  (call_indirect $greet$dispatch (type $greet_sig)
    (local.get $p)
    (local.get $style)
    ;; Combined index calculation
    (i32.add
      (i32.mul
        (i32.load (local.get $p))      ;; person_tag
        (i32.const 3))                  ;; num_style_variants
      (i32.load (local.get $style)))))  ;; style_tag
```

**Lookup**: O(1) — single table access after index calculation.

### Approach B: Cascading Tables (see Strategy 3)

Use separate tables per first argument type. More modular but adds indirection.

---

## Performance Characteristics

### Time Complexity

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Type tag lookup | O(1) | Single memory load |
| Table index calculation | O(1) | Arithmetic on tags |
| Dispatch (single arg) | O(1) | One `call_indirect` |
| Dispatch (N args, flattened) | O(1) | One `call_indirect` |
| Direct call (static type) | O(1) | No dispatch overhead |

### Space Complexity

| Component | Size |
|-----------|------|
| Type tag per value | 4 bytes (i32) |
| Table per generic function | `num_variants * sizeof(funcref)` |
| Specialized functions | One per variant (code duplication) |

### Benchmarks (Theoretical)

Compared to direct calls:
- **Indirect call overhead**: ~2-5 cycles on modern WASM runtimes
- **Type tag load**: 1 memory access (likely cached)
- **Total overhead**: Negligible for most applications

---

## Trade-offs

### Advantages

| Advantage | Explanation |
|-----------|-------------|
| **O(1) dispatch** | Single table lookup regardless of variant count |
| **Zero overhead for static types** | Direct calls bypass dispatch entirely |
| **Clean separation** | One table per function, easy to understand |
| **WASM idiomatic** | Uses `call_indirect` as designed |
| **No reflection** | Type tags are internal, not exposed |
| **Sealed unions fit perfectly** | All variants known at compile time |

### Disadvantages

| Disadvantage | Explanation |
|--------------|-------------|
| **Code duplication** | Each variant gets specialized code |
| **Type tag overhead** | 4 bytes per value |
| **Table proliferation** | One table per generic function |
| **Combinatorial explosion** | N×M variants for 2 union params |

### Mitigations

- **Code duplication**: Shared logic can be extracted to helper functions
- **Type tag overhead**: Acceptable for struct-heavy languages
- **Table proliferation**: WASM 3.0 supports 2³²-1 tables
- **Combinatorial explosion**: Only generate variants that are actually used (dead code elimination)

---

## When to Use

### Ideal For

- Languages with **sealed unions** (known at compile time)
- **Struct-based** data models (type tag fits naturally)
- **Performance-critical** dispatch (O(1) required)
- **Single or few-argument** dispatch
- Compilers targeting **WASM 3.0**

### Less Suitable For

- **Open/extensible** type systems (runtime type registration)
- **Deep inheritance** hierarchies (many variants)
- Scenarios requiring **runtime reflection**
- Memory-constrained environments (type tag overhead matters)

---

## Relationship to TinyWhale Requirements

| Requirement | How Strategy 1 Addresses It |
|-------------|----------------------------|
| O(1) lookup | ✅ Single memory load + table access |
| Multi-argument dispatch | ✅ Flattened table or cascading (see Strategy 3) |
| Sealed unions | ✅ All variants known, tables sized exactly |
| No reflection | ✅ Type tags internal to compiler |
| Progressive enhancement | ✅ Add optional syntax, compiler generates unions |

---

## Next Steps

If this strategy is selected:

1. **Design type tag layout** — Decide on struct field ordering
2. **Implement table generation** — Per-function table emission in codegen
3. **Add dispatch wrapper generation** — For functions taking union types
4. **Optimize static dispatch** — Direct calls when types known
5. **Handle multi-argument dispatch** — Choose flattened vs cascading approach
