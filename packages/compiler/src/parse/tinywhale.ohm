TinyWhale {
  // Program structure: newlines are required between lines, not consumed as whitespace
  // This ensures "panic panic" (two statements on one line) is rejected
  // Line? after newline allows blank lines between statements
  Program (a program) = Line? (newline Line?)* newline?
  Line (a line) = IndentedLine | DedentLine | RootLine

  // RootLine tries Statement first, then falls back to Expression
  // Statement covers specific constructs (FuncDecl, RecordTypeDecl, TypeAlias, etc.)
  // Expression covers the general case (BindingExpr, PanicExpr, etc.)
  RootLine = Statement | Expression

  // Newline (required between lines, not treated as whitespace)
  newline = "\n" | "\r\n" | "\r"

  // IndentedLine can contain a MatchArm, Statement, FieldDecl, or FieldInit
  // FieldDecl (with :) for type declarations or nested record init (context-dependent)
  // FieldInit (with =) for value assignments
  // When dedenting from level N to level M (where M > 0), tokenizer emits both indent and dedent tokens.
  // anyDedent* handles the dedent tokens that follow the indent marker.
  IndentedLine = indentToken anyDedent* IndentedContent?
  IndentedContent = MatchArm | FieldInit | FieldDecl | Statement
  DedentLine = anyDedent+ Statement?

  // Statements
  // BindingExpr added as catch-all for new `x = value` syntax without explicit type
  Statement = RecordTypeDecl | TypeAlias | MatchBinding | MatchExpr | FuncDecl | FuncBinding | PrimitiveBinding | RecordBinding | PanicStatement | BindingExpr
  PanicStatement = panic

  // Function forward declaration: factorial: (i32) -> i32
  FuncDecl = identifier colon FuncType

  // Lambda expression: (x: i32): i32 -> x * 2
  // LambdaBody can be:
  //   - Single inline expression: (x: i32): i32 -> x * 2
  //   - Block with expression sequence:
  //       (x: i32): i32 ->
  //           y: i32 = x * 2
  //           y + 1
  Lambda = lparen ParameterList? rparen (colon TypeRef)? arrow LambdaBody
  ParameterList = Parameter (comma Parameter)*
  Parameter = identifier colon TypeRef
  LambdaBody = LambdaBlock | Expression
  LambdaBlock = newline LambdaBlockLine (newline LambdaBlockLine)*
  LambdaBlockLine = indentToken anyDedent* BlockExpression
  BlockExpression = FuncDecl | FuncBinding | PrimitiveBinding | MatchBinding | MatchExpr | Expression

  // Function binding: double = (x: i32): i32 -> x * 2
  // With optional type annotation: add: Add = (a: i32, b: i32): i32 -> a + b
  FuncBinding = identifier (colon TypeRef)? equals Lambda

  // Record type declaration: Point (followed by indented FieldDecls)
  // Use negative lookahead to avoid matching TypeAlias (= TypeRef) or bindings (: Type)
  RecordTypeDecl = upperIdentifier ~(equals | colon)

  // Type alias (no `type` keyword): Add = (i32, i32) -> i32
  TypeAlias = upperIdentifier equals TypeRef

  // Primitive type reference (types that require inline expression)
  PrimitiveTypeRef = ListType | RefinementType | typeKeyword

  // Binding for primitive types: expression required
  PrimitiveBinding = identifier colon PrimitiveTypeRef equals Expression

  // Binding for record types: no expression, block follows
  RecordBinding = identifier colon upperIdentifier

  // TypeAnnotation used by MatchBinding
  TypeAnnotation = colon TypeRef

  // Field declaration inside type (on indented line)
  FieldDecl = lowerIdentifier colon TypeRef

  // Field value initialization: x = 50
  FieldInit = lowerIdentifier equals Expression

  // Type reference (primitives or user-defined)
  // ListType handles iterative nesting: i32[]<size=4>[]<size=2>
  TypeRef = ListType | RefinementType | FuncType | upperIdentifier | typeKeyword

  // Function type: (i32, i32) -> i32
  FuncType = lparen TypeList? rparen arrow TypeRef
  TypeList = TypeRef (comma TypeRef)*

  // Refinement type: i32<min=0, max=100>
  RefinementType = typeKeyword TypeBounds

  // Type bounds for constraints: <min=0, max=100> or <size=4>
  TypeBounds = lessThan BoundList greaterThan
  BoundList = Bound (comma Bound)*
  Bound = boundKeyword equals minus? intLiteral
  boundKeyword = minKeyword | maxKeyword | sizeKeyword
  minKeyword = "min" ~identifierPart
  maxKeyword = "max" ~identifierPart

  // List type with size bound: i32[]<size=4> or nested i32[]<size=4>[]<size=2>
  // Uses iterative suffixes to avoid left recursion
  ListType = ListTypeBase ListTypeSuffix+
  ListTypeSuffix = lbracket rbracket TypeBounds
  ListTypeBase = RefinementType | upperIdentifier | typeKeyword
  sizeKeyword = "size" ~identifierPart

  // Upper-case identifier for type names
  upperIdentifier = upper (alnum | "_")*

  // Lower-case identifier for field/variable names
  lowerIdentifier = ~keyword lower (alnum | "_")*

  // Match expression: result: Type = match scrutinee
  MatchBinding = identifier TypeAnnotation equals MatchExpr
  MatchExpr = matchKeyword Expression

  // Match arm: Pattern -> Expression
  MatchArm = Pattern arrow Expression

  // Pattern grammar
  Pattern = OrPattern
  OrPattern = PrimaryPattern (pipe PrimaryPattern)*
  PrimaryPattern = WildcardPattern | LiteralPattern | BindingPattern

  WildcardPattern = underscore
  LiteralPattern = minus? intLiteral
  BindingPattern = ~keyword ~underscore identifier

  // Expressions (precedence from lowest to highest)
  // BindingExpr has lowest precedence - allows x = 42 and x: Type = 42
  Expression = BindingExpr | LogicalOrExpr
  BindingExpr = identifier (colon TypeRef)? equals Expression

  LogicalOrExpr = LogicalAndExpr (pipePipe LogicalAndExpr)*
  LogicalAndExpr = BitwiseOrExpr (ampAmp BitwiseOrExpr)*
  BitwiseOrExpr = BitwiseXorExpr (bitwiseOr BitwiseXorExpr)*
  BitwiseXorExpr = BitwiseAndExpr (caret BitwiseAndExpr)*
  BitwiseAndExpr = CompareExpr (ampersand CompareExpr)*
  CompareExpr = AddExpr (compareOp AddExpr)*
  AddExpr = MulExpr (addOp MulExpr)*
  MulExpr = UnaryExpr (mulOp UnaryExpr)*

  UnaryExpr = unaryOp UnaryExpr  -- unary
            | PrimaryExpr        -- primary

  PrimaryExpr = PostfixExpr
              | Lambda              -- lambda
              | lparen Expression rparen  -- paren
              | ListLiteral
              | MatchExpr
              | PanicExpr
              | identifier
              | floatLiteral
              | intLiteral

  // Panic as expression - type is Never (bottom type)
  PanicExpr = panic

  // Postfix expressions: only identifiers can be postfix bases
  PostfixExpr = FuncCall | IndexAccess | FieldAccess
  FuncCall = PostfixableBase lparen ArgumentList? rparen
  ArgumentList = Expression (comma Expression)*
  FieldAccess = PostfixableBase (dot lowerIdentifier)+
  IndexAccess = PostfixIndexBase (lbracket intLiteral rbracket)+
  PostfixIndexBase = FieldAccess | PostfixableBase

  // Only identifiers can be postfix bases (not parens, literals, or list literals)
  PostfixableBase = identifier

  // List literal: [1, 2, 3]
  ListLiteral = lbracket ListElements rbracket
  ListElements = Expression (comma Expression)*

  // Operator groups
  compareOp = lessEqual | greaterEqual | lessThan | greaterThan | equalEqual | bangEqual
  addOp = plus | minus
  mulOp = star | slash | percentPercent | percent | greaterGreaterGreater | greaterGreater | lessLess
  unaryOp = minus | tilde

  // Keywords
  keyword = panic | typeKeyword | matchKeyword
  typeKeyword = i32 | i64 | f32 | f64
  panic = "panic" ~identifierPart
  matchKeyword = "match" ~identifierPart
  i32 = "i32" ~identifierPart
  i64 = "i64" ~identifierPart
  f32 = "f32" ~identifierPart
  f64 = "f64" ~identifierPart
  identifierPart = alnum | "_"

  // Identifiers and literals (from tokenizer)
  identifier = ~keyword letter (alnum | "_")*
  intLiteral = digit+ (("e" | "E") "+"? digit+)?
  floatLiteral = digit+ "." digit+ (("e" | "E") ("+" | "-")? digit+)?
  colon = ":"
  equals = "="
  minus = "-"
  arrow = "->"
  underscore = "_" ~identifierPart
  pipe = "|"

  // Arithmetic operators
  plus = "+"
  star = "*"
  slash = "/"
  percent = "%"
  percentPercent = "%%"
  tilde = "~"

  // Comparison operators (order matters: longer first)
  lessEqual = "<="
  greaterEqual = ">="
  lessThan = "<"
  greaterThan = ">"
  equalEqual = "=="
  bangEqual = "!="

  // Shift operators (order matters: longer first)
  greaterGreaterGreater = ">>>"
  greaterGreater = ">>"
  lessLess = "<<"

  // Bitwise operators
  ampersand = "&"
  caret = "^"
  bitwiseOr = "|" ~"|"

  // Logical operators
  ampAmp = "&&"
  pipePipe = "||"

  // Grouping
  lparen = "("
  rparen = ")"
  lbracket = "["
  rbracket = "]"

  // List separator
  comma = ","

  // Field access
  dot = "."

  // Lexical token rules (marker followed by indent level)
  indentToken = "⇥" digit+
  anyDedent = dedentZero | dedentNonZero
  dedentZero = "⇤0"
  dedentNonZero = "⇤" nonZeroDigit digit*
  nonZeroDigit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

  // Whitespace: spaces and tabs only (newlines are handled explicitly in Program rule)
  // This ensures "panic panic" on one line is rejected
  space := " " | "\t" | comment
  comment = "#" (~("#" | "\n" | "\r" | anyDedent) any)* ("#" | &"\n" | &"\r" | &anyDedent | end)
}
