import * as ohm from 'ohm-js';

/**
 * Represents a position in the source text.
 */
export interface SourcePosition {
  line: number;
  column: number;
}

/**
 * Represents an indentation token with its metadata.
 */
export interface IndentInfo {
  type: 'tab' | 'space';
  start: SourcePosition;
  end: SourcePosition;
  depth: number;
}

/**
 * Represents a parsed line from the preprocessed input.
 */
export interface ParsedLine {
  indent: IndentInfo | null;
  content: string;
  lineNumber: number;
}

/**
 * Result of parsing a program.
 */
export interface ParseResult {
  lines: ParsedLine[];
  succeeded: boolean;
  message?: string;
}

/**
 * TinyWhale Grammar Source
 *
 * This grammar is designed to work with preprocessed input where leading
 * whitespace has been converted to explicit indent tokens.
 *
 * Token format from preprocessor:
 *   indent_<type>:<startLine>,<startCol>;<endLine>,<endCol> <content>
 *
 * Examples:
 *   indent_tab:1,1;1,1 hello     (1 tab on line 1)
 *   indent_space:2,1;2,4 world   (4 spaces on line 2)
 */
const grammarSource = String.raw`
TinyWhale {
  // ============================================================
  // Top-level structure
  // All rules use lowercase (lexical) to avoid implicit space skipping,
  // which is critical for significant whitespace handling.
  // ============================================================

  // Program is newline-terminated lines plus optional final line without newline
  program = terminatedLine* finalLine?

  // A line that ends with newline (most lines)
  terminatedLine = indentedLine
                 | blankLine
                 | contentLine

  // Final line at end of file (no trailing newline)
  finalLine = indentedLineFinal
            | contentLineFinal

  // ============================================================
  // Line types
  // ============================================================

  // Indented line: indent token + space + content + newline
  indentedLine = indentToken " " restOfLine newline

  // Indented line at end of file (no trailing newline)
  indentedLineFinal = indentToken " " restOfLine end

  // Blank line: just a newline
  blankLine = newline

  // Content line: non-empty content followed by newline
  contentLine = lineStart restOfLine newline

  // Content line at end of file
  contentLineFinal = lineStart restOfLine end

  // ============================================================
  // Indentation tokens (generated by preprocessor)
  // ============================================================

  // Full indent token with position info
  indentToken = indentTab | indentSpace

  indentTab = "indent_tab:" position ";" position

  indentSpace = "indent_space:" position ";" position

  // Position format: line,column (1-indexed)
  position = digit+ "," digit+

  // ============================================================
  // Line content helpers
  // ============================================================

  // First char of a content line (not an indent token)
  lineStart = ~indentToken ~newline any

  // Rest of line after first char (can be empty)
  restOfLine = (~newline any)*

  // ============================================================
  // Lexical rules
  // ============================================================

  newline = "\n" | "\r\n" | "\r"
}
`;

/**
 * The compiled TinyWhale grammar.
 */
export const grammars = ohm.grammars(grammarSource);

/**
 * The base TinyWhale grammar for indentation handling.
 */
export const TinyWhaleGrammar = grammars['TinyWhale'];

/**
 * Parse a position string like "2,4" into a SourcePosition.
 */
function parsePosition(posStr: string): SourcePosition {
  const [line, column] = posStr.split(',').map(Number);
  return { line, column };
}

/**
 * Helper to get line number from a node's source position.
 */
function getLineNumber(node: ohm.Node): number {
  const interval = node.source;
  const textBefore = interval.sourceString.substring(0, interval.startIdx);
  return (textBefore.match(/\n/g) || []).length + 1;
}

/**
 * Create semantics for the TinyWhale grammar.
 */
export function createSemantics() {
  const semantics = TinyWhaleGrammar.createSemantics();

  // Extract IndentInfo from indent tokens
  semantics.addOperation<IndentInfo>('toIndentInfo', {
    indentTab(_prefix, startPos, _semi, endPos) {
      const start = parsePosition(startPos.sourceString);
      const end = parsePosition(endPos.sourceString);
      return {
        type: 'tab',
        start,
        end,
        depth: end.column,
      };
    },

    indentSpace(_prefix, startPos, _semi, endPos) {
      const start = parsePosition(startPos.sourceString);
      const end = parsePosition(endPos.sourceString);
      return {
        type: 'space',
        start,
        end,
        depth: end.column,
      };
    },

    indentToken(token) {
      return token.toIndentInfo();
    },
  });

  // Extract content string from various line elements
  semantics.addOperation<string>('toContent', {
    restOfLine(_chars) {
      return this.sourceString;
    },

    lineStart(_char) {
      return this.sourceString;
    },
  });

  // Convert line nodes to ParsedLine
  semantics.addOperation<ParsedLine | null>('toLine', {
    indentedLine(indentToken, _space, restOfLine, _newline) {
      const indent = indentToken.toIndentInfo();
      return {
        indent,
        content: restOfLine.sourceString,
        lineNumber: indent.start.line,
      };
    },

    indentedLineFinal(indentToken, _space, restOfLine, _end) {
      const indent = indentToken.toIndentInfo();
      return {
        indent,
        content: restOfLine.sourceString,
        lineNumber: indent.start.line,
      };
    },

    blankLine(_newline) {
      return null;
    },

    contentLine(lineStart, restOfLine, _newline) {
      const lineNumber = getLineNumber(this);
      return {
        indent: null,
        content: lineStart.sourceString + restOfLine.sourceString,
        lineNumber,
      };
    },

    contentLineFinal(lineStart, restOfLine, _end) {
      const lineNumber = getLineNumber(this);
      return {
        indent: null,
        content: lineStart.sourceString + restOfLine.sourceString,
        lineNumber,
      };
    },

    terminatedLine(line) {
      return line.toLine();
    },

    finalLine(line) {
      return line.toLine();
    },
  });

  // Collect all lines from a Program
  semantics.addOperation<ParsedLine[]>('toLines', {
    program(terminatedLines, finalLine) {
      const lines: ParsedLine[] = [];

      // Process terminated lines
      for (const line of terminatedLines.children) {
        const parsed = line.toLine();
        if (parsed !== null) {
          lines.push(parsed);
        }
      }

      // Process final line if present
      if (finalLine.children.length > 0) {
        const parsed = finalLine.children[0].toLine();
        if (parsed !== null) {
          lines.push(parsed);
        }
      }

      return lines;
    },
  });

  return semantics;
}

/**
 * Default semantics instance.
 */
export const semantics = createSemantics();

/**
 * Parse preprocessed input and return structured result.
 *
 * @param input - Preprocessed input string (with indent tokens)
 * @returns Parse result with lines and success status
 */
export function parse(input: string): ParseResult {
  const matchResult = TinyWhaleGrammar.match(input);

  if (matchResult.failed()) {
    return {
      lines: [],
      succeeded: false,
      message: matchResult.message,
    };
  }

  const lines = semantics(matchResult).toLines();

  return {
    lines,
    succeeded: true,
  };
}

/**
 * Match input against the grammar without extracting semantics.
 *
 * @param input - Preprocessed input string
 * @returns Ohm match result
 */
export function match(input: string): ohm.MatchResult {
  return TinyWhaleGrammar.match(input);
}

/**
 * Trace a parse for debugging purposes.
 *
 * @param input - Preprocessed input string
 * @returns Trace string
 */
export function trace(input: string): string {
  return TinyWhaleGrammar.trace(input).toString();
}
